# SW 공학 day1 (2024-06-11)

# 1장. 소프트웨어 공학 소개
## 1-1. SW 공학이란
* 요구사항, 아키텍처, 코딩, 테스트로 구성된다.
* 소프트웨어 개발과 관련된 실 세계의 다양한 문제를 해결하기 위해(혹은 소프트웨어 위기를 극복하기 위해) 과학적인 지식을 체계적으로 적용하는 학문.
* 소프트웨어 개발 과정에서 과학적인 지식을 체계적으로 적용하는 학문 분야, 소프트웨어의 개발과 운영, 유지보수, 소멸에 대한 체계적인 접근 방법.
* 소프트웨어 개발에 사용되는 방법이 일회성이 아닌 반복 사용이 가능함.

## 1-2. SW 특징
* **복잡성**
  
  소프트웨어는 규칙적이고 정형화된 구조가 없다. 따라서 이해하고 관리하는데 어려움이 있다.
  
* **순응성**
  
  사용자 요구나 환경 변화에 따라 적절히 변형하는 것이 용이하다. 호환성, 유연성이라고도 부른다.
  
* **유형성**
  
  흔히 소프트웨어는 보고 만질 수 없어 무형이라고 한다. 그러나 소프트웨어는 프로그램과 관련된 문서들의 집합으로 형태를 가지고 있다.

* **비제조성**

  소프트웨어는 개발되는 것이고 하드웨어는 제조되는 것이다.
 
* **비조립성**

  하드웨어는 부품 조립에 의해 생산되지만 소프트웨어는 주문제작에 의해 생산된다.
  
* **견고성**
  
  'Soft'가 주는 의미는 소프트웨어 개발의 유연성으로 받아들여지고 다시 수정용이성으로 연결된다. SW가 한 번 구조성을 잃으면 유지보수에 어려움이 있음.

## 1-3. SW 위기
* 1960년대 1970년대 하드웨어 기술의 급속한 발전과 비교된 소프트웨어 생산 능력 따라가지 못하여 발생하는 문제현상
```
- 사용자는 새롭고 다양한 분야의 소프트웨어를 요구하는 현상
- 하드웨어 성능 발전에 따라 과거보다 더욱 크고 복잡한 소프트웨어를 요구하는 현상
- 개발비용이 초과되고 개발 일정이 지연되는 현상
- 소프트웨어 성능과 품질 저하 현상
- 유지보수의 어려움에 의한 비용증가 현상
```

* SW 위기 현상 문제를 극복하기 위해 탄생한 학문 분야 -> SW 공학

* 문제점 : 개발예산 초과, 개발일정 지연, 생산성 저조, 품질 미흡

* 원인 : SW특성 이해 부족, 관리 부재, 개발 전문 인력 부족, SW 복잡도 증가, SW 개발 비용 증가

## 1-4. SW 공학 목적
* 높은 생산성과 좋은 품질(소프트웨어가 올바르게 작동하는 정도, 사용자 요구사항 만족 정도, 유지보수의 용이함 정도)의 소프트웨어 제작

## 1-5. SW 공학 목표
* 복잡도 낮춤, 비용 최소화, 개발 기간 단축, 대규모 프로젝트 관리, 고품질 소프트웨어, 효율성

## 1-6. 소프트웨어 공학 3가지 주제
### 프로세스
1. **계획** : 프로젝트에 대한 경제성, 기술력, 자원, 일정에 대한 가능성 분석
2. **요구분석** : 사용자 요구사항을 수집하고, 분석하여 시스템이 무슨 기능을 하는지 정의
3. **설계** : 요구 분석 단계에서 파악된 시스템 기능들을 어떻게 제공할 것인지 고민. 시스템 전체 구조뿐 아니라 소프트웨어 구조와 각 모듈에 대한 상세 처리 절차를 정의
4. **구현** : 프로그래밍 하는 단계. 설계서 바탕으로 코드로 변환되며 단위 모듈에 대한 검사 포함
5. **테스팅** : 통합에 대한 검사, 전체적으로 완성된 시스템 기능과 성능에 대한 만족도 검사 수행
6. **유지보수** : 소프트웨어가 고객에게 인도된 후 발생하는 다양한 변경 요청에 대한 지원 

### 품질보증
* 자주 확인하고 체크하여 품질 보증
* 품질을 좌우하는 세가지 : 인력, 프로세스, 기술

### 프로젝트 관리
* 프로젝트 계획, 자원관리, 리스크 관리, 프로젝트 수행과 모니터링

## 1-7. 소프트웨어 공학의 다양한 관점
### 계획 관점
* 계획없이 효과적으로 프로젝트를 통제 관리하는 것은 불가능
* 초기 계획 필요하나 계획 활동은 소프트웨어 개발 프로세스에서 독립된 활동이 아니라 개발 전 과정에 걸쳐 반복 수행되는 것이 필요
* 계획하지 않는 것은 *실패*를 계획하는 것이다

### 분석/설계 관점
* 대부분의 개발 비용을 차지하는 유지보수 비용 절감을 위해 개발 초기 단계에서 결함을 발견하기 위한 기술, 방법, 도구들에 대해 연구하는 학문
* 개발 초기 단계의 오류 수정은 단지 문서 수정을 의미

### 테스트 관점
* 프로세스 후반부에 수행되는 오류 검사는 초기 단계에서 수행되는 검사에 비해 프로젝트 비용 증가
* 테스트 활동은 구현 후 수행되는 독립된 활동이 아니라 소프트웨어 개발 프로세스 전 과정에 걸쳐 수행되는 것이 필요

### 문서화 관점
* 각 활동의 결과물을 문서로 작성하는 것이 필요
* 만일 작성되지 않는다면 유지보수와 검사활동은 불가능
* 결국, 문서화 과정 역시 독립적으로 존재하는 하나의 활동이 아니라 시스템 개발 전 과정을 통해 수행되는 것이 필요

### 유지보수 관점
* 현대적인 유지보수 개볌은 개발 후 유지보수뿐 아니라 소프트웨어 개발 프로세스 모든 활동에서 발생하는 모든 변경에 대한 유지보수를 의미
* 소프트웨어 개발 비용의 대부분(70~80%)은 개발 후 유지보수 비용으로 소모
* 결국, 소프트웨어 공학의 주된 관심사는 개발 후 유지보수 활동에 소비되는 비용을 줄이기 위한 노력
---
# 2장. 프로세스와 방법론
* 프로세스 : 단계적 작업의 틀을 정의한 것. 무엇을 하는가에 중점

* 방법론 : 어떻게 하는가에 집중. 가이드라인에 초점

방법론 > 프로세스 > 모델

## 2-1. 소프트웨어 생명주기
* SDLC(Software Development Life Cycle)
* 소프트웨어 개발 프로세스는 소프트웨어가 탄생되어 운용되고 유지보수를 거쳐 폐기되기까지 전 과정을 의미

## 2-2. 프로세스
```
* 소프트웨어 시스템을 구축하기 위해 수행되는 작업의 단계
* 소프트웨어 개발에 대한 기술적, 관리적 이슈를 다루는 작업
* 서로 협력하여 전체 목적을 만족
```

* **계획** : 시간, 비용, 인력, ROI(투자 대비 수익)
* **요구분석** : 요구(시스템이 가져야 할 능력과 조건), What의 단계, 가장 중요하고 어려운 단계(작은 차이가 큰 오류로 변함) / 결과물->요구분석서(SRS: Software Requirement Specification)  
* **설계** : How의 단계, 솔루션에 집중/ 아키텍처- 데이터베이스 - UI - 상세 설계 / 결과물 -> 설계명세서
* **구현** : Do it 단계, 코딩과 단위 테스트
* **통합과 테스트** : 통합해 나가면서 테스트 시작, 모듈의 통합으로 시작, 점차 완성된 모듈을 추가 / 통합은 개발자, 테스트는 QA팀이 주로 담당
* **설치와 유지보수** : 설치는 개발 프로젝트의 일부, 유지보수(결함 고치기, 새 기능 추가, 성능 추가)는 별개

=> **좋은 프로세스란?** 예측 가능, 테스팅과 유지보수 용이성, 변경을 쉽게 다룰 수 있는 프로세스, 결함 제거

## 2-3. 프로세스 모델
일반적인 모델이 될만한 프로세스를 기술한 것 (ex. 폭포수 모델, 나선형 모델, 애자일 프로세스...)

- **폭포수 모델** : 순서적; 각 단계 사이에 중복이나 상호작용이 없음
    - 장점 : 프로세스가 단순, 중간 산출물이 명확해 관리하기 좋음
    - 단점 : 소용없는 다종의 문서를 생산할 가능성 있음, 애매한 부분이 남아 있거나 프로세스 진행 과정에 변경될 때 부담이 크다, 테스트 작업이 후반에 시작된다.
    - 적용 => 크기가 작고 단순한것에 사용
- **V 모델** : 검증을 강화하는 관점에서 폭포수 모델을 확장한 모델
    - 장점 : 오류를 줄일 수 있음
    - 단점 : 반복이 없어 변경을 다루기가 쉽지 않음
    - 적용 => 신뢰성이 중요한 분야에 적용(자동차, 국방, 위성, 은행...)
- **프로토타이핑 모델** : 요구 사항에 대한 피드백을 받기 위해 시스템을 실험적으로 만들어 사용자에게 보여주고 평가하게 하는 방법
    - 장점 : 사용자의 의견 반영이 잘됨
    - 단점 : 오해 - 기대심리 유발, 관리가 어려움
    - 적용 => 요구가 불투명할때, 혁신적인 기술 사용 시 적용
- **진화적 모델** : 출시 계획 기반으로 일정을 잡는 것
    - 장점 : 몇 가지 기능이 부족하더라도 초기에 사용 교육 가능, 사용자의 요구를 빠르게 반영, 시장을 빨리 형성, 예상 못한 문제를 신속하고 꾸준하게 고칠 수 있다.
    - 단점 : 프로젝트 관리가 복잡해 작은 프로젝트는 부적합, 끝이 안보일 수 있어 실패 위험이 커짐, 프로젝트의 진행이 위험 분석에 크게 의존
    - 적용 => 빠른 시간 안에 시장에 출시해야 할 때 적용
- **나선형 모델** : 소프트웨어의 기능을 나눠 점증적으로 개발
    - 장점 : 대규모 시스템 개발에 적합, 반복적인 개발 및 테스트->강인성 향상, 한 사이클에 추가 못한 기능은 다음 단계에 추가 가능
    - 단점 : 관리가 복잡, 위험 분석을 잘못하여 지나친 경우 피해가 큼, 성공 사례가 많이 알려지지 않음
    - 적용 => 재정적 또는 기술적으로 위험 부담이 큰 경우, 요구 사항이나 아키텍처 이해에 어려운 경우
- **애자일 프로세스** : 폭포수 프로세스의 단점을 해결, 절차와 도구보다 개인과 소통을 중시
    - 에자일 선언
      ```
      1. 프로세스나 도구보다는 개인과 상호 작용을
      2. 포괄적인 문서보다는 작동하는 소프트웨어를
      3. 계약에 대한 협상보다는 고객과의 협력을
      4. 계획을 고수하기 보다는 변화에 대응을
         
      더욱 가치 있게 여긴다.
      ```
  
## 2-4. 지원 프로세스


## 2-5. 방법론


